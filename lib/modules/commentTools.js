import _ from 'lodash';
import { $ } from '../vendor';
import * as Modules from '../core/modules';
import {
	Alert,
	DAY,
	Thing,
	checkKeysForEvent,
	click,
	currentSubreddit,
	escapeHTML,
	isPageType,
	loggedInUser,
	niceKeyCode,
	range,
	regexes,
} from '../utils';
import { Storage, ajax } from '../environment';
import * as AccountSwitcher from './accountSwitcher';
import * as SettingsNavigation from './settingsNavigation';
import * as UserTagger from './userTagger';

export const module = {};

module.moduleID = 'commentTools';
module.moduleName = 'Editing Tools';
module.category = ['Comments', 'Submissions'];
module.description = 'Provides tools and shortcuts for composing comments, text posts, wiki pages, and other markdown text areas.';
module.options = {
	userAutocomplete: {
		type: 'boolean',
		value: true,
		description: 'Show user autocomplete tool when typing in posts, comments and replies',
		advanced: true,
	},
	subredditAutocomplete: {
		type: 'boolean',
		value: true,
		description: 'Show subreddit autocomplete tool when typing in posts, comments and replies',
		advanced: true,
	},
	formattingToolButtons: {
		type: 'boolean',
		value: true,
		description: 'Show formatting tools (bold, italic, tables, etc.) to the edit form for posts, comments, and other snudown/markdown areas.',
	},
	keyboardShortcuts: {
		dependsOn: 'formattingToolButtons',
		type: 'boolean',
		value: true,
		description: 'Use keyboard shortcuts to apply styles to selected text',
	},
	boldKey: {
		dependsOn: 'keyboardShortcuts',
		type: 'keycode',
		value: [66, false, true, false, false], // ctrl-b
		description: 'Keyboard shortcut to make text bold.',
	},
	italicKey: {
		dependsOn: 'keyboardShortcuts',
		type: 'keycode',
		value: [73, false, true, false, false], // ctrl-i
		description: 'Keyboard shortcut to make text italic.',
	},
	strikeKey: {
		dependsOn: 'keyboardShortcuts',
		type: 'keycode',
		value: [83, false, true, false, false], // ctrl-s
		description: 'Keyboard shortcut to add a strikethrough.',
	},
	superKey: {
		dependsOn: 'keyboardShortcuts',
		type: 'keycode',
		value: [187, false, true, true, false], // ctrl-+ (ctrl-shift-=)
		description: 'Keyboard shortcut to make text superscript.',
	},
	linkKey: {
		dependsOn: 'keyboardShortcuts',
		type: 'keycode',
		value: [75, false, true, false, false], // ctrl-k
		description: 'Keyboard shortcut to add a link.',
	},
	quoteKey: {
		dependsOn: 'keyboardShortcuts',
		type: 'keycode',
		value: [190, false, true, true, false], // ctrl-> (strl-shift-.)
		description: 'Keyboard shortcut to quote text.',
	},
	ctrlEnterSubmitsComments: {
		type: 'boolean',
		value: true,
		description: 'Pressing Ctrl+Enter or Cmd+Enter will submit your comment/wiki edit.',
	},
	ctrlEnterSubmitsPosts: {
		type: 'boolean',
		value: true,
		description: 'Pressing Ctrl+Enter or Cmd+Enter will submit your post.',
	},
	commentingAs: {
		type: 'boolean',
		value: true,
		description: 'Shows your currently logged in username to avoid posting from the wrong account.',
	},
	highlightIfAltAccount: {
		dependsOn: 'commentingAs',
		type: 'boolean',
		value: true,
		description: 'Put in bold the "Commenting As" part if you are using an alt account. The first account in the Account Switcher module is considered as your main account.',
	},
	showInputLength: {
		type: 'boolean',
		value: true,
		description: 'When submitting, display the number of characters entered in the title and text fields and indicate when you go over the 300 character limit for titles.',
		advanced: true,
		bodyClass: true,
	},
	macroButtons: {
		type: 'boolean',
		value: true,
		description: 'Add macro buttons to the edit form for posts, comments, and other snudown/markdown text areas.',
		bodyClass: true,
	},
	macros: {
		dependsOn: 'macroButtons',
		type: 'table',
		addRowText: '+add shortcut',
		fields: [{
			name: 'label',
			type: 'text',
		}, {
			name: 'text',
			type: 'textarea',
		}, {
			name: 'category',
			type: 'text',
		}, {
			name: 'key',
			type: 'keycode',
		}],
		value: [
			['reddiquette', '[reddiquette](/wiki/reddiquette) '],
			['Promote RES', '[Reddit Enhancement Suite](http://redditenhancementsuite.com "also /r/Enhancement") '],
			['Current timestamp', '{{now}} '],
		],
		description: 'Add buttons to insert frequently used snippets of text.',
	},
	keepMacroListOpen: {
		dependsOn: 'macroButtons',
		type: 'boolean',
		value: false,
		description: 'After selecting a macro from the dropdown list, do not hide the list.',
		advanced: true,
	},
	macroPlaceholders: {
		dependsOn: 'macroButtons',
		type: 'boolean',
		value: true,
		description: `
			When using macro, replace placeholders in text via pop-up prompt.
			<p>Example macro text:<br>
			The {{adj1}} {{adj2}} {{animal}} jumped over the lazy {{dog_color}} dog. The {{animal}} is so {{adj1}}!
			</p>
		`,
	},
	enabledOnBanMessages: {
		type: 'boolean',
		value: true,
		description: 'Show the comment tools on the ban note textbox.',
		advanced: true,
	},
};

module.include = [
	'comments',
	'inbox',
	'submit',
	'profile',
	'modqueue',
	'subredditAbout',
	/^https?:\/\/(?:[\-\w\.]+\.)?reddit\.com\/r\/[\-\w\.]+\/wiki\/(?:create|edit)(\/\w+)?/i,
];

module.loadDynamicOptions = () => {
	if (magicPlaceholders.length) {
		module.options.macroPlaceholders.description += `
			<br><br>Some placeholders are automatically filled in when you use the macro:
			<dl>
			${magicPlaceholders.map(({ matches, description }) => `
				<dt>${matches.map(token => `{{${token}}}`).join('<br>')}</dt>
				${description ? `<dd>${description}</dd>` : ''}
			`).join('')}
			</dl>
		`;
	}
};

const SUBMIT_LIMITS = {
	STYLESHEET: 128 * 1024,
	SIDEBAR: 5120,
	DESCRIPTION: 500,
	WIKI: 512 * 1024,
	COMMENT: 10000,
	POST: 40000,
	POST_TITLE: 300,
	BAN_MESSAGE: 1000,
};
const macroCallbackTable = [];
const macroKeyTable = [];

module.go = () => {
	const $body = $('body');

	$body.on('click', 'div.markdownEditor-wrapper a:not(.userTagLink)', function(e) {
		e.preventDefault();

		const index = $(this).data('macro-index');
		const box = findTextareaForElement(this)[0];
		// const box = $(this).closest('.usertext-edit, .RESDialogContents, .wiki-page-content').find('textarea[name=text], textarea[name=description], textarea[name=public_description]')[0];
		if (box === null) {
			console.error('Failed to locate textarea.');
			return;
		}
		const handler = macroCallbackTable[index];
		if (handler === null) {
			console.error('Failed to locate find callback.');
			return;
		}

		module::handler(this, box);

		box.focus();
		// Fire an input event to refresh the preview
		const inputEvent = document.createEvent('HTMLEvents');
		inputEvent.initEvent('input', true, true);
		box.dispatchEvent(inputEvent);
	}).on('click', '.RESMacroDropdownTitle', function(e) {
		const thisCat = e.target;
		if (thisCat.classList.contains('openMacro')) {
			thisCat.classList.remove('openMacro');
		} else {
			$('.RESMacroWrappingSpan span').removeClass('openMacro');
			thisCat.classList.add('openMacro');
		}
		// position the drop down so it's flush with the right of the category button.
		$(this).next().css({
			top: `${thisCat.offsetTop + thisCat.offsetHeight}px`,
			left: `${thisCat.offsetLeft + thisCat.offsetWidth - thisCat.nextSibling.offsetWidth}px`,
		});
	});

	if (module.options.showInputLength.value) {
		$body.on('input', '.usertext-edit textarea, #title-field textarea, #BigEditor textarea, #wiki_page_content, #ban_message', function() {
			updateCounter(this);
		});
	}

	if (module.options.keyboardShortcuts.value) {
		$body.on('keydown', '.usertext-edit textarea, #BigEditor textarea, #wiki_page_content, #ban_message', function(e) {
			if (e.keyCode === KEYS.ESCAPE) {
				if (!$autoCompletePop.is(':visible')) {
					// Blur from the editor on escape, so we can return to using the keyboard nav.
					// NOTE: The big editor closes on ESC so this won't be reached in that case.
					$(this).blur();
					e.preventDefault();
				}

				return;
			}

			for (const [testedKeyArray, macroIndex] of macroKeyTable) {
				if (checkKeysForEvent(e, testedKeyArray)) {
					const handler = macroCallbackTable[macroIndex];
					module::handler(null, this);

					// Fire an input event to refresh the preview
					const inputEvent = document.createEvent('HTMLEvents');
					inputEvent.initEvent('input', true, true);
					this.dispatchEvent(inputEvent);

					e.preventDefault();
					return;
				}
			}
		});
	}

	if (module.options.ctrlEnterSubmitsComments.value) {
		onCtrlEnter(
			'.usertext-edit textarea, #BigEditor textarea, #wiki_page_content',
			e => {
				const currentForm = $(e.target).closest('form');
				const saveButton = currentForm.find('.save')[0] || currentForm.find('#wiki_save_button')[0] || $('.BEFoot button')[0];
				click(saveButton);
			}
		);
	}

	if (module.options.ctrlEnterSubmitsPosts.value) {
		onCtrlEnter(
			'#title-field textarea, #text-field textarea, #url, #sr-autocomplete, input.captcha',
			() => {
				const $captcha = $('input.captcha:not(.cap-text)');
				if ($captcha.length && $captcha.val() === '') {
					$captcha.focus();
				} else {
					click($('.spacer .btn')[0]);
				}
			}
		);
	}

	if (module.options.subredditAutocomplete.value || module.options.userAutocomplete.value) {
		addAutoCompletePop();
	}

	// Perform initial setup of tools over the whole page
	attachCommentTools();
};

export function getCommentTextarea(elem) {
	return $(elem || document.body).find('textarea[name][name!=share_to][name!=message]');
}

function attachCommentTools(elem) {
	getCommentTextarea(elem).each(attachEditorToUsertext);
}

function getFieldLimit(elem) {
	switch (elem.name) {
		case 'title':
			return SUBMIT_LIMITS.POST_TITLE;
		case 'text': // https://github.com/honestbleeps/Reddit-Enhancement-Suite/issues/829
			if (isPageType('submit') || $(elem).closest('.thing').hasClass('self')) {
				return SUBMIT_LIMITS.POST;
			}
			return SUBMIT_LIMITS.COMMENT;
		case 'description':
			return SUBMIT_LIMITS.SIDEBAR;
		case 'public_description':
			return SUBMIT_LIMITS.DESCRIPTION;
		case 'content':
			return SUBMIT_LIMITS.WIKI;
		case 'ban_message':
			return SUBMIT_LIMITS.BAN_MESSAGE;
		// case 'description_conflict_old':
		// case 'public_description_conflict_old':
		default:
			return 1337; // should be easier to debug than 0
	}
}

function attachEditorToUsertext() {
	if (this.hasAttribute('data-max-length')) {
		return;
	}
	const limit = getFieldLimit(this);

	this.setAttribute('data-limit', limit);

	if (this.name === 'title') {
		return;
	}

	if (this.id === 'ban_message' && !module.options.enabledOnBanMessages.value) {
		return;
	}

	if (this.id === 'ban_message') {
		this.style.width = '500px';
		this.style.height = '100px';
	}

	const bar = makeEditBar();
	if (this.id === 'wiki_page_content' || this.id === 'ban_message') {
		$(this).parent().prepend(bar);
	} else {
		$(this).parent().before(bar);
	}
	updateCounter(this);
}

export function updateCounter(textarea) {
	const length = $(textarea).val().length;
	const limit = textarea.getAttribute('data-limit');
	const counter = $(textarea).parent().parent().find('.RESCharCounter');
	counter.attr('title', `character limit: ${length}/${limit}`);
	counter.text(`${length}/${limit}`);
	if (length > limit) {
		counter.addClass('tooLong');
	} else {
		counter.removeClass('tooLong');
	}
}

let cachedEditBar;

export function makeEditBar() {
	if (cachedEditBar) {
		return $(cachedEditBar).clone();
	}

	const $editBar = $('<div class="markdownEditor">');
	// Wrap the edit bar in a <div> of its own
	const wrappedEditBar = $('<div class="markdownEditor-wrapper">').append($editBar);

	if (module.options.commentingAs.value) {
		// show who we're commenting as...
		const commentingAsMessage = location.href.match(/^https?:\/\/(?:[\-\w\.]+\.)?reddit\.com\/r\/[\-\w\.]+\/about\/banned\/?/i) ? 'Moderating as' : 'Speaking as';

		const commentingAs = $('<div class="commentingAs">')
			.html(`${commentingAsMessage}: `)
			.append($('#header-bottom-right .user a')
				.clone()
				.wrap('<span class="commentingAsUser"></span>')
				.parent()
			);
		if (Modules.isRunning(UserTagger)) {
			UserTagger.applyTagToAuthor(commentingAs.find('a')[0], true);
		}
		if (module.options.highlightIfAltAccount.value && AccountSwitcher.module.options.accounts.value.length && loggedInUser() && loggedInUser().toLowerCase() !== AccountSwitcher.module.options.accounts.value[0][0].toLowerCase()) {
			commentingAs.addClass('highlightedAltAccount');
		}
		wrappedEditBar.append(commentingAs);
	}

	if (module.options.formattingToolButtons.value) {
		const shortcuts = module.options.keyboardShortcuts.value;
		$editBar.append(makeEditButton('<b>Bold</b>', `bold${shortcuts ? ` (${niceKeyCode(module.options.boldKey.value)})` : ''}`, module.options.boldKey.value, 'btn-bold', (button, box) => {
			wrapSelection(box, '**', '**');
		}));
		$editBar.append(makeEditButton('<i>Italic</i>', `italic${shortcuts ? ` (${niceKeyCode(module.options.italicKey.value)})` : ''}`, module.options.italicKey.value, 'btn-italic', (button, box) => {
			wrapSelection(box, '*', '*');
		}));
		$editBar.append(makeEditButton('<del>strike</del>', `strike${shortcuts ? ` (${niceKeyCode(module.options.strikeKey.value)})` : ''}`, module.options.strikeKey.value, 'btn-strike', (button, box) => {
			wrapSelection(box, '~~', '~~');
		}));
		$editBar.append(makeEditButton('<sup>sup</sup>', `super${shortcuts ? ` (${niceKeyCode(module.options.superKey.value)})` : ''}`, module.options.superKey.value, 'btn-superscript', (button, box) => {
			wrapSelectedWords(box, '^');
		}));
		$editBar.append(makeEditButton('Link', `link${shortcuts ? ` (${niceKeyCode(module.options.linkKey.value)})` : ''}`, module.options.linkKey.value, 'btn-link', (button, box) => {
			linkSelection(box);
		}));
		$editBar.append(makeEditButton('>Quote', `quote${shortcuts ? ` (${niceKeyCode(module.options.quoteKey.value)})` : ''}`, module.options.quoteKey.value, 'btn-quote', (button, box) => {
			wrapSelectedLines(box, '> ', '');
		}));
		$editBar.append(makeEditButton('<span style="font-family: monospace">Code</span>', 'code', null, 'btn-code', (button, box) => {
			wrapSelectedLines(box, '    ', '');
		}));
		$editBar.append(makeEditButton('&bull;Bullets', 'bullet list', null, 'btn-list-unordered', (button, box) => {
			wrapSelectedLines(box, '* ', '');
		}));
		$editBar.append(makeEditButton('1.Numbers', 'number list', null, 'btn-list-ordered', (button, box) => {
			wrapSelectedLines(box, '1. ', '');
		}));
		$editBar.append(makeEditButton('<span style="border: 1px black solid;">Table</span>', 'table', null, 'btn-table', (button, box) => {
			// First check if the selected text is a table, this also clean the selection
			const selectedText = box.value.substring(box.selectionStart, box.selectionEnd).replace(/^[\s]+/, '').replace(/[\s]+$/, '').split('\n'); // In fact, if the header start by '   |' this is not a table. But it's better to accept it then after editing the table it will work
			let isTable;
			if (selectedText.length >= 2) {
				if (selectedText[0].includes('|')) {	// Check if there is at least one '|' to check if it's a table
					selectedText[0] = selectedText[0].replace(/^\|/, '').replace(/\|\s+$/, ''); // Avoid '| foo | bar |' instead of 'foo | bar'
					const numSeparator = selectedText[0].split('|').length;
					/*
						numSeparator can be 0 for example with :
							foo |
							----|
							bar |
						but it's important to check for each line before removing starting/ending '|' if there is at least one '|' to check if it's really a table
					*/
					isTable = true;

					// Check the HEADER/BODY separator
					selectedText[1] = selectedText[1].replace(/\|[^|\-]+$/, ''); // '-|-|-|ILOVECOOKIE' is correct, so clean it. But '-|-|-ILOVECOOKIE' is not correct if there is 3 column (okay if there is less though, but will not be detected). Also '-      |     -    |   -' is correct and will not be detected.
					selectedText[1] = selectedText[1].replace(/-/g, '--'); // Required to allow -|-|- to work (else the split would give ['', '|-'])
					if (!selectedText[1].includes('-|') && !selectedText[1].includes('|-')) {
						isTable = false;
					}
					selectedText[1] = selectedText[1].replace(/^\]+/, '').replace(/[\s|]+$/, '');
					if (selectedText[1].split('-|-').length < numSeparator) { // Check if there is enough '-|-'
						isTable = false;
					}
					if (/[^|\-]/.test(selectedText[1])) { // If the separator contain an other character than | or -
						isTable = false;
					}

					// Now check the BODY
					if (isTable) {
						for (const i of range(2, selectedText.length)) {
							if (!selectedText[i].includes('|')) {
								isTable = false;
								break;
							}
							selectedText[i] = selectedText[i].replace(/^\|/, '').replace(/[\s|]+$/, '');
							if (selectedText[i].split('|').length !== numSeparator)	{ // Check if there is the same '|' number
								// In fact this should be >= but that would means make disappear some content, so I will consider this is not a table
								// in fact this is useless, because if we omit last cell they will be void. But this would complicate the generation part by managing void cell and the code is enough complicate.
								isTable = false;
								break;
							}
						}
					}
				}
			}
			let startTable;
			if (isTable) {
				// The selected text is a table, now transform it to HTML!
				startTable = selectedText.reduce((prevTable, currText, i) => {
					if (i === 1) {
						return prevTable;
					}

					return `${prevTable}<tr><td>${escapeHTML(currText).replace(/\|/g, '</td><td>')}</td></tr>`;
				}, '');
			} else {
				startTable = '<tr><td>Foo</td><td>Bar</td></tr><tr><td>Foo</td><td>Bar</td></tr>';
			}
			Alert.open(`<div class="buttonContainer"></div><table class="commentPreview" contenteditable="true">${startTable}</table>`, { cancelable: true })
				.then(() => {
					let generatedTable = '\n\n';
					let generatedTableSeparation = '';
					$('#alert_message tr:first td').each(function() {
						const text = $(this).text().replace(/[\n|]/g, '');
						generatedTable += `${text} | `;
						generatedTableSeparation += '-'.repeat(text.length);
						generatedTableSeparation += '|';
					});
					generatedTableSeparation = generatedTableSeparation.substr(0, generatedTableSeparation.length - 1);
					generatedTable = `${generatedTable.substr(0, generatedTable.length - 3)}\n${generatedTableSeparation}\n`;
					$('#alert_message tr:gt(0)').each(function() {
						$(this).find('td').each(function() {
							generatedTable += `${$(this).text().replace(/[\n|]/g, '')} | `;
						});
						generatedTable = `${generatedTable.substr(0, generatedTable.length - 3)}\n`;
					});
					if (isTable) {
						replaceSelection(box, generatedTable);
					} else {
						wrapSelection(box, generatedTable, '');
					}
					$(box).trigger('input'); // update preview
				});

			const addRow = Alert.makeButton('+ Row');
			const remRow = Alert.makeButton('- Row');
			const addCol = Alert.makeButton('+ Col');
			const remCol = Alert.makeButton('- Col');
			addRow.addEventListener('click', () => {
				const nbCol = $('#alert_message tr:first td').length;
				const newRow = '<td>text</td>'.repeat(nbCol);
				$('#alert_message table').append(`<tr>${newRow}</tr>`);
			});
			remRow.addEventListener('click', () => {
				if ($('#alert_message tr').length > 1) {
					$('#alert_message table tr:last').remove();
				}
			});
			addCol.addEventListener('click', () => {
				$('#alert_message table tr').append('<td>text</td>');
			});
			remCol.addEventListener('click', () => {
				if ($('#alert_message tr:first td').length > 1) {
					$('#alert_message table tr td:last-of-type').remove();
				}
			});

			const $buttonContainer = $('#alert_message .buttonContainer');
			$buttonContainer.append(addRow);
			$buttonContainer.append(remRow);
			$buttonContainer.append(addCol);
			$buttonContainer.append(remCol);
		}));
	}

	if (module.options.showInputLength.value) {
		const $counter = $('<span class="RESCharCounter" title="character limit: 0/?????">0/?????</span>');
		$editBar.prepend($counter); // prepend for more reliable css floating.
		$('.submit-page #title-field span.title').prepend('<span class="RESCharCounter" title="character limit: 0/300">0/300</span>');
	}

	if (module.options.macroButtons.value) {
		buildMacroDropdowns(wrappedEditBar);

		const addMacroButton = makeEditButton(module.options.macros.addRowText, null, null, 'btn-macro btn-macro-add', () => {
			SettingsNavigation.loadSettingsPage(module.moduleID, 'macros');
			$('.RESMacroWrappingSpan span').removeClass('openMacro');
		});
		addButtonToMacroGroup('', addMacroButton);
	}

	cachedEditBar = wrappedEditBar;
	return cachedEditBar;
}

const macroDropDownTable = {};

function getMacroGroup(groupName) {
	// Normalize and supply a default group name{}
	groupName = (groupName || '').toString().trim() || 'macros';
	if (groupName in macroDropDownTable) {
		return macroDropDownTable[groupName];
	} else {
		const macroGroup = macroDropDownTable[groupName] = {};
		macroGroup.titleButton = $(`<span class="RESMacroDropdownTitle">${groupName}</span>`);
		macroGroup.container = $('<span class="RESMacroDropdown"></span>');
		macroGroup.dropdown = $('<ul class="RESMacroDropdownList"></ul>');
		macroGroup.container.append(macroGroup.dropdown);
		return macroGroup;
	}
}

function addButtonToMacroGroup(groupName, button) {
	const group = getMacroGroup(groupName);
	group.dropdown.append($('<li>').append(button));
}

function buildMacroDropdowns(editBar) {
	const macros = module.options.macros.value;

	for (const [title, text, category, key] of macros) {
		const button = makeEditButton(title, null, key, 'btn-macro', (button, box) => {
			macroSelection(box, text, '');
		});
		addButtonToMacroGroup(category, button);
	}

	const $macroWrapper = $('<span class="RESMacroWrappingSpan">');

	const defaultGroup = getMacroGroup('');
	$macroWrapper.append(defaultGroup.titleButton);
	$macroWrapper.append(defaultGroup.container);

	for (const category in macroDropDownTable) {
		if (category === 'macros') {
			continue;
		}
		$macroWrapper.append(macroDropDownTable[category].titleButton);
		$macroWrapper.append(macroDropDownTable[category].container);
	}
	editBar.append($macroWrapper);
}

function makeEditButton(label, title, key, cls, handler) {
	if (label === null) {
		label = 'unlabeled';
	}
	if (title === null) {
		title = '';
	}
	const macroButtonIndex = macroCallbackTable.length;
	const button = $('<a>').safeHtml(label).attr({
		class: `edit-btn ${cls}`,
		title,
		href: '#',
		tabindex: 1,
		'data-macro-index': macroButtonIndex,
	});

	if (key && key[0] !== null) {
		macroKeyTable.push([key, macroButtonIndex]);
	}
	macroCallbackTable[macroButtonIndex] = handler;
	return button;
}

function linkSelection(box) {
	let url = prompt('Enter the URL:', '');
	if (url !== null) {
		// escape parens in url
		url = url.replace(/[\(\)]/g, '\\$&');
		// escape brackets and parens in text
		wrapSelection(box, '[', `](${url})`, text => text.replace(/[\[\]\(\)]/g, '\\$&'));
	}
}

function macroSelection(box, macroText) {
	if (!module.options.keepMacroListOpen.value) {
		$('.RESMacroWrappingSpan span').removeClass('openMacro');
	}
	if (module.options.macroPlaceholders.value) {
		const formatText = selectedText => fillPlaceholders(box, macroText, selectedText);
		wrapSelection(box, '', '', formatText);
	} else {
		wrapSelection(box, macroText, '');
	}
}

function fillPlaceholders(box, macroText, selectedText) {
	const placeholders = macroText.match(/\{\{\w+\}\}/g);

	if (placeholders) {
		const completedPlaceholders = {};

		for (const placeholder of placeholders) {
			if (completedPlaceholders.hasOwnProperty(placeholder)) {
				continue;
			}
			completedPlaceholders[placeholder] = true;

			const placeholderInnerText = placeholder.substring(2, placeholder.length - 2).toLowerCase();
			let value = getMagicPlaceholderValue(placeholderInnerText, macroText, selectedText, box);
			if (value === undefined) {
				value = promptForPlaceholderValue(placeholder, macroText);
			}

			if (value === null) {
				// user cancelled
				break;
			}

			// Replace placeholder with value
			macroText = macroText.replace(new RegExp(placeholder, 'g'), value);
		}
	}

	return macroText;
}

function getMagicPlaceholderValue(placeholder, macroText, selectedText, box) {
	const handler = magicPlaceholders.find(current => current.matches.includes(placeholder));

	if (handler) {
		return handler.handle(macroText, selectedText, box);
	}
}

const magicPlaceholders = [
	{
		matches: ['subreddit'],
		description: 'The current subreddit, in the form /r/subreddit',
		handle(macroText, selectedText, box) {
			const subredditName = new Thing(box).getSubreddit() || currentSubreddit();

			if (subredditName) {
				return `/r/${subredditName}`;
			}
		},
	}, {
		matches: ['me', 'my_username'],
		description: 'Your username, in the form /u/username',
		handle() {
			const username = loggedInUser();
			if (username) {
				return `/u/${username}`;
			}
		},
	}, {
		matches: ['op', 'op_username'],
		description: 'The username of the "original poster", in the form /u/username. On a post\'s comments page, this the person who made the post; on a PM / modmail, this is the person who started the conversation',
		handle(macroText, selectedText, box) {
			let profile;
			if (isPageType('comments')) {
				profile = document.querySelector('.sitetable .author');
			} else {
				let $next = $(box);
				let furthest;
				do {
					if ($next && $next.length) furthest = $next;
					$next = $next.parent().closest('.sitetable');
				} while ($next.length);

				profile = furthest.find('.author')[0];
			}

			if (profile) {
				return `/u/${profile.pathname.match(regexes.profile)[1]}`;
			}
		},
	}, {
		matches: ['url'],
		description: 'The current page\'s URL, like http://www.reddit.com/r/Enhancement/comments/123abc/example_post',
		handle() {
			return document.location.href;
		},
	}, {
		matches: ['reply_to', 'reply_to_username'],
		description: 'The username of person you\'re replying to, in the form /u/username. ',
		handle(macroText, selectedText, box) {
			let $base = $(box);
			const isEditing = $base.closest('.thing, .entry').hasClass('entry');

			if (isEditing) {
				$base = $base.closest('.thing').parent();
			}

			const profile = $base.closest('.thing').find('.entry .author')[0];

			if (!profile) {
				return getMagicPlaceholderValue('op', macroText, selectedText, box);
			} else {
				return `/u/${profile.pathname.match(regexes.profile)[1]}`;
			}
		},
	}, {
		matches: ['selected', 'selection'],
		description: 'The text which is currently selected (highlighted)',
		handle(macroText, selectedText) {
			return selectedText;
		},
	}, {
		matches: ['now'],
		description: 'The current date and time in your locale',
		handle() {
			const date = new Date();
			return date.toTimeString();
		},
	}, {
		matches: ['today'],
		description: 'The current date in your locale',
		handle() {
			const date = new Date();
			return date.toDateString();
		},
	}, {
		matches: ['escaped'],
		description: 'The selected text, escaped for snudown/markdown. Useful for text emoji like ¯\\_(ツ)_/¯',
		handle(macroText, selectedText) {
			return selectedText.replace(/[\[\]()\\\*\^~\-_.]/g, '\\$&');
		},
	},
];

function promptForPlaceholderValue(placeholder, macroText) {
	// Get value for placeholder
	const display = `${macroText}\n\n\nEnter replacement for ${placeholder}:`;
	const value = placeholder;

	return prompt(display, value);
}

function wrapSelection(box, prefix, suffix, escapeFunction) {
	if (box === null) {
		return;
	}
	// record scroll top to restore it later.
	const scrollTop = box.scrollTop;

	// We will restore the selection later, so record the current selection.
	const selectionStart = box.selectionStart;
	const selectionEnd = box.selectionEnd;

	const text = box.value;
	const beforeSelection = text.substring(0, selectionStart);
	let selectedText = text.substring(selectionStart, selectionEnd);
	const afterSelection = text.substring(selectionEnd);

	// Markdown doesn't like it when you tag a word like **this **. The space messes it up. So we'll account for that because Firefox selects the word, and the followign space when you double click a word.
	let trailingSpace = '';
	let cursor = selectedText.length - 1;
	while (cursor > 0 && selectedText[cursor] === ' ') {
		trailingSpace += ' ';
		cursor--;
	}
	selectedText = selectedText.substring(0, cursor + 1);

	if (typeof escapeFunction === 'function') {
		selectedText = escapeFunction(selectedText);
	}

	box.value = beforeSelection + prefix + selectedText + suffix + trailingSpace + afterSelection;

	box.selectionEnd = beforeSelection.length + prefix.length + selectedText.length;
	if (selectionStart === selectionEnd) {
		box.selectionStart = box.selectionEnd;
	} else {
		box.selectionStart = beforeSelection.length + prefix.length;
	}

	box.scrollTop = scrollTop;
}

function replaceSelection(box, replacement) {
	if (box === null) {
		return;
	}
	// record scroll top to restore it later.
	const scrollTop = box.scrollTop;

	// We will restore the selection later, so record the current selection.
	const selectionStart = box.selectionStart;
	const selectionEnd = box.selectionEnd;

	const text = box.value;
	const beforeSelection = text.substring(0, selectionStart);
	const afterSelection = text.substring(selectionEnd);


	box.value = beforeSelection + replacement + afterSelection;

	box.selectionEnd = beforeSelection.length + replacement.length;

	box.scrollTop = scrollTop;
}

function wrapSelectedLines(box, prefix, suffix) {
	const scrollTop = box.scrollTop;
	let selectionStart = box.selectionStart;
	let selectionEnd = box.selectionEnd;

	const text = box.value;
	let startPosition = 0;
	const lines = text.split('\n');
	for (const i of range(0, lines.length)) {
		let lineStart = startPosition;
		let lineEnd = lineStart + lines[i].length;
		// Check if either end of the line is within the selection
		if (selectionStart <= lineStart && lineStart <= selectionEnd || selectionStart <= lineEnd && lineEnd <= selectionEnd ||
				// Check if either end of the selection is within the line
				lineStart <= selectionStart && selectionStart <= lineEnd || lineStart <= selectionEnd && selectionEnd <= lineEnd) {
			lines[i] = prefix + lines[i] + suffix;
			// Move the offsets separately so we don't throw off detection for the other end
			let startMovement = 0;
			let endMovement = 0;
			if (lineStart < selectionStart) {
				startMovement += prefix.length;
			}
			if (lineEnd < selectionStart) {
				startMovement += suffix.length;
			}
			if (lineStart < selectionEnd) {
				endMovement += prefix.length;
			}
			if (lineEnd < selectionEnd) {
				endMovement += suffix.length;
			}

			selectionStart += startMovement;
			selectionEnd += endMovement;
			lineStart += prefix.length;
			lineEnd += prefix.length + suffix.length;
		}
		// Remember the newline
		startPosition = lineEnd + 1;
	}

	box.value = lines.join('\n');
	box.selectionStart = selectionStart;
	box.selectionEnd = selectionEnd;
	box.scrollTop = scrollTop;
}

function wrapSelectedWords(box, prefix) {
	const scrollTop = box.scrollTop;
	let selectionStart = box.selectionStart;
	const selectionEnd = box.selectionEnd;

	const text = box.value;
	const beforeSelection = text.substring(0, selectionStart);
	const selectedWords = text.substring(selectionStart, selectionEnd).split(' ');
	const afterSelection = text.substring(selectionEnd);

	let selectionModify = 0;

	for (const i of range(0, selectedWords.length)) {
		if (selectedWords[i] !== '') {
			if (selectedWords[i].includes('\n')) {
				const newLinePosition = selectedWords[i].lastIndexOf('\n') + 1;
				selectedWords[i] = selectedWords[i].substring(0, newLinePosition) + prefix + selectedWords[i].substring(newLinePosition);
				selectionModify += prefix.length;
			}
			if (selectedWords[i].charAt(0) !== '\n') {
				selectedWords[i] = prefix + selectedWords[i];
			}
			selectionModify += prefix.length;
		} else if (selectedWords[i] === '' && selectedWords.length === 1) {
			// If nothing is selected, stick the prefix in there and move the cursor to the right side.
			selectedWords[i] = prefix + selectedWords[i];
			selectionModify += prefix.length;
			selectionStart += prefix.length;
		}
	}

	box.value = beforeSelection + selectedWords.join(' ') + afterSelection;
	box.selectionStart = selectionStart;
	box.selectionEnd = selectionEnd + selectionModify;
	box.scrollTop = scrollTop;
}

// Unused, kept for posterity (?)
/* const firstlod;
function lod() {
	if (!firstlod) {
		firstlod = true;
		$('body').append('<div id="RESlod" style="display: none; position: fixed; left: 0; top: 0; right: 0; bottom: 0; background-color: #ddd; opacity: 0.9; z-index: 99999;"><div style="position: relative; text-align: center; width: 400px; height: 300px; margin: auto;"><div style="font-size: 100px; margin-bottom: 10px;">&#3232;_&#3232;</div> when you do this, people direct their frustrations at <b>me</b>... could we please maybe give this a rest?</div></div>');
	}
	$('#RESlod').fadeIn('slow', function() {
		setTimeout(function() {
			$('#RESlod').fadeOut('slow');
		}, 5000);
	});
} */

export const KEYS = {
	BACKSPACE: 8,
	TAB: 9,
	ENTER: 13,
	ESCAPE: 27,
	SPACE: 32,
	PAGE_UP: 33,
	PAGE_DOWN: 34,
	END: 35,
	HOME: 36,
	LEFT: 37,
	UP: 38,
	RIGHT: 39,
	DOWN: 40,
	NUMPAD_ENTER: 108,
	COMMA: 188,
};

let $autoCompletePop;

function addAutoCompletePop() {
	$autoCompletePop = $('<div id="autocomplete_dropdown" class="drop-choices srdrop inuse" style="display:none;">');
	$autoCompletePop.on('click mousedown', '.choice', function() {
		autoCompleteHideDropdown();
		autoCompleteInsert(this.innerHTML);
	});
	$('body').append($autoCompletePop);

	$('body').on({
		keyup: autoCompleteTrigger,
		keydown: autoCompleteNavigate,
		blur: autoCompleteHideDropdown,
	}, '.usertext .usertext-edit textarea, #BigText, #wiki_page_content');
}

let autoCompleteLastTarget;

const autoCompleteDebounce = _.debounce(async (type, query) => {
	let names;

	if (type === 'r') {
		names = await getSubredditCompletions(query);
	} else if (type === 'u') {
		names = await getUserCompletions(query);
	} else {
		throw new Error(`Invalid autocomplete type: ${type}`);
	}

	autoCompleteUpdateDropdown(names);
	autoCompleteSetNavIndex(0);
}, 200);

function autoCompleteTrigger(e) {
	// \0x08 is backspace
	if (/[^A-Za-z0-9 \x08]/.test(String.fromCharCode(e.keyCode))) {
		return true;
	}
	autoCompleteLastTarget = e.target;
	const matchRE = /\W\/?([ru])\/([\w\.]*)$/;
	const matchSkipRE = /\W\/?([ru])\/([\w\.]*)\s$/;
	const fullText = $(this).val();
	const prefixText = fullText.slice(0, this.selectionStart);
	let match = matchRE.exec(` ${prefixText}`);
	if (match !== null) {
		if (match[1] === 'r' && !module.options.subredditAutocomplete.value) {
			return undefined;
		}
		if (match[1] === 'u' && !module.options.userAutocomplete.value) {
			return undefined;
		}
	}

	if (match === null || match[2] === '' || match[2].length > 10) {
		if (e.keyCode === KEYS.SPACE || e.keyCode === KEYS.ENTER) {
			match = matchSkipRE.exec(` ${prefixText}`);
			if (match) {
				autoCompleteInsert(match[2]);
			}
		}
		return autoCompleteHideDropdown();
	}

	const type = match[1];
	const query = match[2].toLowerCase();

	autoCompleteDebounce(type, query);
}

async function getSubredditCompletions(query) {
	const { names } = await ajax({
		method: 'POST',
		url: '/api/search_reddit_names.json',
		data: { query },
		type: 'json',
		cacheFor: DAY,
	});

	return names;
}

async function getUserCompletions(query) {
	const tags = await Storage.get('RESmodules.userTagger.tags') || {};
	const tagNames = Object.keys(tags);
	const pageNames = Array.from(document.querySelectorAll('.author')).map(e => e.textContent);
	return [...tagNames, ...pageNames]
		.filter(e => e.toLowerCase().startsWith(query))
		.sort()
		.reduce((prev, current) => {
			// Removing duplicates
			if (prev[prev.length - 1] !== current) {
				prev.push(current);
			}
			return prev;
		}, []);
}

function autoCompleteNavigate(e) {
	// Don't mess with shortcuts for fancier cursor movement
	if (e.metaKey || e.shiftKey || e.ctrlKey || e.altKey) return undefined;
	const entries = $autoCompletePop.find('a.choice');
	let index = +$autoCompletePop.find('.selectedItem').data('index');
	if ($autoCompletePop.is(':visible')) {
		switch (e.keyCode) {
			case KEYS.DOWN:
			case KEYS.RIGHT:
				e.preventDefault();
				if (index < entries.length - 1) index++;
				autoCompleteSetNavIndex(index);
				break;
			case KEYS.UP:
			case KEYS.LEFT:
				e.preventDefault();
				if (index > 0) index--;
				autoCompleteSetNavIndex(index);
				break;
			case KEYS.TAB:
			case KEYS.ENTER:
				e.preventDefault();
				$(entries[index]).click();
				break;
			case KEYS.ESCAPE:
				e.preventDefault();
				autoCompleteHideDropdown();
				return false;
			default:
				break;
		}
	}
}

function autoCompleteSetNavIndex(index) {
	const entries = $autoCompletePop.find('a.choice');
	entries.removeClass('selectedItem');
	entries.eq(index).addClass('selectedItem');
}

function autoCompleteHideDropdown() {
	$autoCompletePop.hide();
}

function autoCompleteUpdateDropdown(names) {
	if (!names.length) return autoCompleteHideDropdown();
	$autoCompletePop.empty();
	names.slice(0, 20).forEach((name, i) => {
		$autoCompletePop.append(`<a class="choice" data-index="${i}">${name}</a>`);
	});

	const textareaOffset = $(autoCompleteLastTarget).offset();
	textareaOffset.left += $(autoCompleteLastTarget).width();
	$autoCompletePop.css(textareaOffset).show();

	autoCompleteSetNavIndex(0);
}

function autoCompleteInsert(inputValue) {
	const textarea = autoCompleteLastTarget;
	const caretPos = textarea.selectionStart;
	let left = textarea.value.substr(0, caretPos);
	const right = textarea.value.substr(caretPos);
	left = left.replace(/(\/?[ru])\/(\w*)\s?$/, `$1/${inputValue} `);
	textarea.value = left + right;
	textarea.selectionStart = textarea.selectionEnd = left.length;
	textarea.focus();
}

function findTextareaForElement(elem) {
	return $(elem)
		.closest('.usertext-edit, .RESDialogContents, .wiki-page-content, .ban-details')
		.find('textarea')
		.filter('#BigText, [name=text], [name=description], [name=public_description], #wiki_page_content, #ban_message')
		.first();
}

export function onCtrlEnter(selector, handler) {
	$(document.body).on('keydown', selector, e => {
		if (e.keyCode === KEYS.ENTER && (e.ctrlKey || e.metaKey)) {
			e.preventDefault();
			handler(e);
		}
	});
}
